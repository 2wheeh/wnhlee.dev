---
author: wonhee
pubDatetime: 2024-08-01T16:32:16.000+09:00
modDatetime:
title: 프론트엔드 기술 면접 오답노트 1
pinned: false
# draft: true
tags:
  - interview
  - bfs
  - websocket
  - canvas
  - javascript
  - garbage collection
  - nodejs
description: 자책은 그만하고 오답노트를 작성해보자.
---

## Table of Contents

## Intro

자책은 그만하고 오답노트를 작성해보자.

## Canvas API vs img tag

> `Canvas API`와 `img 태그` 어떻게 다른가요?

1. 렌더링 방식: `Canvas API`는 어떤 그래픽을 그릴지 Application 수준에서 픽셀 단위로 조작하고, `img` 태그는 파일시스템에서, 혹은 url에서 이미지를 가져와서 렌더링한다. 렌더링 로직은 브라우져 엔진이 담당한다.

2. 파일 저장 및 사용성: `Canvas API`에서 그린 그래픽 이미지를 유저가 저장하기 위해서는 추가적인 로직을 구현해야한다. 예를들면, 저장 버튼의 클릭 이벤트 핸들러에서 `canvas.toDataURL()`, `canvas.toBlob()` 같은 메서드를 조작하는 방식이다. 반면 `img` 태그는 브라우저에서 저장 기능을 제공한다. 또한 `img` 태그는 `alt` 속성으로 대체 텍스트를 제공할 수 있어서 접근성이 더 뛰어나다.

> 단순히 이미지를 표시하는 상황이라면 둘 중 성능은 뭐가 더 좋을까요?

단순 이미지 표시의 경우에는 `img` 태그가 더 빠르고 효율적이다. `img`는 단지 이미지를 보여주기 만을 위해 동작하고, 브라우저 엔진이 이미지를 바로 렌더링한다. 반면, `Canvas API`는 `canvas` 엘리먼트를 DOM에 추가하고, 컨텍스트를 생성하고, 그림을 그리는 등의 추가적인 로직을 수행해야하기 때문이다.

모던 브라우저들은 `img` 태그의 이미지를 렌더링할 떄, GPU 가속을 기본적으로 사용한다. `Canvas API`를 사용할 때도 GPU 가속을 사용할 수 있지만, 위에서 말한 것 처럼 자바스크립트 메인 스레드를 거쳐서 렌더링 로직을 실행해야하고 이는 브라우저 엔진이 렌더링을 최적화하는 `img` 태그에 비해 느릴 수 있다.

## Websocket Protocol

> Websocket 커넥션은 어떤 과정을 거쳐서 이루어지나요?

## React 19, React Compiler

> React 19에서는 어떤 변화가 있었나요?

> React Compiler는 무엇인가요?

## OAuth

> OAuth 프로토콜 흐름을 설명해보세요.

## BFS Time Complexity

> BFS의 시간복잡도는 어떻게 되나요?

간선수와 정점수에 선형적으로 비례한다.

O(V+E)

여기서 V(vertex)는 정점의 수, E(edge)는 간선의 수이다.

O(V)는 정점을 방문하는 시간:

- BFS는 모든 정점을 한 번씩 방문
- 각 정점을 큐에서 뺌 -> O(V)

O(E)는 간선을 탐색하는 시간:

- 각 정점을 방문할 떄, 그 정점과 연결된 모든 간선을 탐색
- 모든 간선은 한 번씩 탐색, 간선 수 만큼 큐에 추가 -> O(E)

일반적으로 표현하는 O(N) 표기법으로 하자면, N이 정점의 수일 때:

- 간선 수가 최소일 때 (i.e. 일반적인 트리 구조) - O(N)
- 간선 수가 최대일 때 (i.e. 모든 정점끼리 서로 연결된 완전 그래프) - O(N^2)

## JavaScript, Thread, Runtime

> JavaScript 의 동작 방식을 설명해보세요.

> JavaScript는 싱글 스레드인가요?

> 언어와 API의 관계를 설명해보세요.

> 서비스 워커에서 무거운 파일을 로드하다가 앱이 죽은 현상을 위의 개념들과 연관지어서 설명해보세요.

## GC on JavaScript

> 자바스크립트의 GC(Garbage Collection)에 대해 설명해보세요.

> JVM의 GC와 어떻게 다른가요?

> 순환참조 문제가 뭔가요? 어떻게 해결할 수 있나요?

GC가 수거해갈 대상을 Reference Counting으로 추적하게 되면 발생할 수 있는 문제다.

예를 들어, A 객체와 B 객체가 서로를 참조하지만 어디에서도 참조하지 않는 경우를 생각해보자.

이 경우 Reference Counting 방식은 A와 B의 참조 카운트가 0이 되지 않아서 GC가 수거하지 못한다.

실제로 IE6에서는 Reference Counting 방식을 사용했었는데, 이런 문제로 메모리 누수가 발생했다.

모던 브라우저들은 이를 해결하기 위해서 Mark-and-Sweep 방식을 사용한다.

Mark-and-Sweep 방식은 루트 객체에서 시작해서 도달 가능한 객체를 마킹하고, 마킹되지 않은 객체를 수거하는 방식이다.

> GC는 메인 스레드에서 동작하나요?

JS에서 GC의 메인 로직(Mark-and-Sweep)은 메인 스레드에서 동작한다.

일부 작업은 성능 최적화를 위해 백그라운드 스레드에서 동작하기도 하며, Node.js의 경우

> GC가 다른 스레드에서 동작한다면, 어떻게 동기화를 할까요?

우선, JS의 GC는 메인 스레드에서 동작한다.

하지만 다른 스레드에서 동작한다고 가정하고 답변해보면,

스레드간 동시성 문제를 해결하기 위해 락이나 뮤텍스 같은 방법으로 동시성 문제를 해결하고,

어쩌구저쩌구를 통해 스레드간 통신을 하게 될 것이다.

> GC가 동작하는 동안 앱이 멈추는 문제는 없나요?

## 그럼에도 불구하고

복기를 하다보니, 조금 절망적인 기분이 든다.

그러나 현명한 자는 실패를 딛고 일어서는 법. 아! 어찌 좌절하리오.
